% Intuito: checar se implementei direito o CST em código
clc,clear,fclose('all');

% Modificação: agora cada superfície tem seu próprio raio do bordo de ataque
% Modificação: alteração do que é multiplicado pelos fatores de escala

% Notas:
% Sendo n o grau do polinomio, temos n+1 variáveis de design
% Fixemos o polinômio em grau 4.
n = 4;

% Imprimir coordenadas?
op = 0;

% Alguns parâmetros
np = 80; % Número de pontos
c = 1; % Comprimento da corda
%x = cosspace_half(0,c,np); 
x = cosspace(0,c,np); 
y1 = zeros(1,length(x));
N1 = 0.5;
N2 = 1;

% Valores mínimos e máximos pras extensões de variáveis
le_R_ext1 = [0.01,0.05];
le_R_ext2 = [0.01,0.04];
A_ext1 = [0,0.3];
A_ext2 = [-0.1,0.1];
B_ext1 = [5,30]; % Limites inferior e superior
B_ext2 = [20,20]; % O primeiro número é a separação mínima do extradorso, o segundo é o limite superior

% Reescrever as extensões
le_R_ext1 = le_R_ext1(1):0.01:le_R_ext1(2);
le_R_ext2 = le_R_ext2(1):0.01:le_R_ext2(2);
A_ext1 = A_ext1(1):0.01:A_ext1(2);
A_ext2 = A_ext2(1):0.01:A_ext2(2);
B_ext1 = B_ext1(1):B_ext1(2); % Limites inferior e superior

check = 0; R = 0;
while check == 0

    % Informações do extradorso
    Rle1 = le_R_ext1(randi(length(le_R_ext1))); 
    beta1 = B_ext1(randi(length(B_ext1)));
    Dz1 = 0;

    A1 = zeros(n+1);
    A1(1) = sqrt(2*Rle1/c);
    A1(2) = A_ext1(randi(length(A_ext1)));
    A1(3) = A_ext1(randi(length(A_ext1)));
    A1(4) = A_ext1(randi(length(A_ext1)));
    A1(5) = tand(beta1) + Dz1/c;
%    f1 = 0.1;
    %A1 = A1*f1;

    % Extensão do ângulo do intradorso
    temp = -beta1:B_ext2(2); % O primeiro número é a separação mínima do extradorso, o segundo é o limite superior

    % Informações do intradorso
    Rle2 = le_R_ext2(randi(length(le_R_ext2)));
    beta2 = temp(randi(length(temp)));
    Dz2 = 0;

    A2 = zeros(n+1);
    A2(1) = sqrt(2*Rle2/c);
    A2(2) = A_ext2(randi(length(A_ext2)));
    A2(3) = A_ext2(randi(length(A_ext2)));
    A2(4) = A_ext2(randi(length(A_ext2)));
    A2(5) = tand(beta2) + Dz2/c;
%    f2 = 0.1;
    %A2 = A2*f2;



    %% Extradorso ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for p = 1:np
        
        % Calcular o polinômio de Bernstein
        sum = 0;
        for r = 0:n
            K = factorial(n)/(factorial(r)*factorial(n-r));
            sum = sum + A1(r+1)*K*x(p)^r*(1-x(p))^(n-r);
        end
        
        % Calcular a ordenada com as funções class e shape ao mesmo tempo
        y1(p) = x(p)^N1*(1-x(p))^N2*sum + x(p)*Dz1/c;
        
    end

    figure(1),clf
    %plot(x,y1),grid on,hold on,axis equal



    %% Intradorso ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    for p = 1:np
        
        % Calcular o polinômio de Bernstein
        sum = 0;
        for r = 0:n
            K = factorial(n)/(factorial(r)*factorial(n-r));
            sum = sum + A2(r+1)*K*x(p)^r*(1-x(p))^(n-r);
        end
        
        % Calcular a ordenada com as funções class e shape ao mesmo tempo
        y2(p) = -x(p)^N1*(1-x(p))^N2*sum + x(p)*Dz2/c;

    end

    coo = [flip(x') flip(y1');
           x(2:end)' y2(2:end)'];
    check = quality(coo,np,c);
%    check = 1;
    R = R + 1;
    if R == 5,break,end
end

%plot(x,y2)


plot(coo(:,1),coo(:,2),'k','linewidth',2),grid on,axis equal,hold on
scatter(coo(:,1),coo(:,2))
%scatter(coo(:,1),coo(:,2))

% Imprimir vetores do aerofólio
fprintf('v_ex = [%.4f, ', Rle1)
fprintf('%.4f, ', A1(2))
fprintf('%.4f, ', A1(3))
fprintf('%.4f, ', A1(3))
fprintf('%.4f, ', beta1)
fprintf('0.1, ')
fprintf('%.4f];\n', Dz1)

fprintf('v_in = [%.4f, ', Rle2)
fprintf('%.4f, ', A2(2))
fprintf('%.4f, ', A2(3))
fprintf('%.4f, ', A2(3))
fprintf('%.4f, ', beta2)
fprintf('0.1, ')
fprintf('%.4f];\n', Dz2)

if op == 1
    ID = fopen('coordenadas.txt','w');
    fprintf(ID,'%f %f\n',coo');
    fclose(ID);
end

%set(gca,'xlim',[0,1]),set(gca,'ylim',[-0.1,0.2]),saveas(gcf,'aoba.png')


% Testar com a função que eu achei na internets
uuh = 0;
if uuh == 1
% Input  : wl = CST weight of lower surface
%          wu = CST weight of upper surface
%          dz = trailing edge thickness
% Output : coord = set of x-y coordinates of airfoil generated by CST

    wl = 1;
    wu = 1;
    dz = 0;
    N = 100;
    [coord] = CST_airfoil(wl,wu,dz,N);
    scatter(coord(:,1),coord(:,2)*f1)
    
endif



